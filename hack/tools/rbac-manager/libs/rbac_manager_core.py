"""
RBAC Manager Core Module.

This module contains the main RBACManager class that handles RBAC resource extraction,
processing, and output in various formats.
"""

import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any

import yaml

from .opm_query import OPMQueryLib
from .catalog_query import CatalogAPIQueryLib


class RBACManager:
    """Main RBAC extraction manager."""
    
    def __init__(self, output_dir: Optional[str] = None, deploy: bool = False, insecure: bool = False):
        """
        Initialize RBAC manager.
        
        Args:
            output_dir: Output directory for YAML files (None for stdout)
            deploy: Deploy directly to cluster via oc apply
            insecure: Skip TLS verification
        """
        self.output_dir = Path(output_dir) if output_dir else None
        if self.output_dir:
            self.output_dir.mkdir(exist_ok=True)
        self.deploy = deploy
        self.insecure = insecure
        
        # Initialize OPM library
        self.opm_lib = OPMQueryLib(insecure=insecure)
        
        # Catalog library will be initialized when API URL is set
        self.catalog_lib = None
    
    def set_catalog_api_url(self, api_url: str):
        """Set the catalog API URL and initialize the catalog library."""
        self.catalog_lib = CatalogAPIQueryLib(api_url, insecure=self.insecure)
    
    def extract_rbac_via_opm(self, image_ref: str, package_name: str) -> Optional[Dict[str, Any]]:
        """Extract RBAC resources via OPM image."""
        return self.opm_lib.extract_rbac_resources(image_ref, package_name)
    
    def extract_rbac_via_catalogd(self, package_name: str, catalog_name: str = "operatorhubio") -> Optional[Dict[str, Any]]:
        """Extract RBAC resources via ClusterCatalog API."""
        if not self.catalog_lib:
            raise Exception("Catalog API URL not set. Use set_catalog_api_url() first.")
        
        return self.catalog_lib.extract_rbac_resources(package_name, catalog_name)
    
    def get_all_packages_via_opm(self, image_ref: str) -> List[str]:
        """Get all packages via OPM."""
        return self.opm_lib.list_packages(image_ref)
    
    def get_all_packages_via_catalogd(self, catalog_name: str = "operatorhubio") -> List[str]:
        """Get all packages via ClusterCatalog API."""
        if not self.catalog_lib:
            raise Exception("Catalog API URL not set. Use set_catalog_api_url() first.")
        
        return self.catalog_lib.list_packages(catalog_name)
    
    def save_rbac_yaml(self, rbac_data: Dict[str, Any], operator_name: str) -> None:
        """
        Save RBAC permissions as YAML files.
        
        Args:
            rbac_data: RBAC resources dictionary
            operator_name: Operator name for directory structure
        """
        operator_dir = self.output_dir / operator_name
        operator_dir.mkdir(exist_ok=True)
        
        # Save ClusterRoles
        if rbac_data['clusterRoles']:
            cluster_role_file = operator_dir / "clusterrole.yaml"
            with open(cluster_role_file, 'w') as f:
                yaml.dump_all(rbac_data['clusterRoles'], f, default_flow_style=False)
            logging.info(f"Saved ClusterRole: {cluster_role_file}")
        
        # Save Roles
        if rbac_data['roles']:
            role_file = operator_dir / "role.yaml"
            with open(role_file, 'w') as f:
                yaml.dump_all(rbac_data['roles'], f, default_flow_style=False)
            logging.info(f"Saved Role: {role_file}")
        
        # Save RoleBinding/ClusterRoleBinding templates
        self._create_binding_templates(operator_dir, rbac_data, operator_name)
    
    def print_rbac_yaml(self, rbac_data: Dict[str, Any], operator_name: str) -> None:
        """
        Print RBAC resources as YAML to stdout.
        
        Args:
            rbac_data: RBAC resources dictionary
            operator_name: Operator name for documentation
        """
        print(f"# RBAC Resources for Operator: {operator_name}")
        print(f"# Generated by RBAC Manager")
        print("---")
        
        # Print ClusterRoles
        if rbac_data['clusterRoles']:
            for cluster_role in rbac_data['clusterRoles']:
                print(yaml.dump(cluster_role, default_flow_style=False).rstrip())
                print("---")
        
        # Print Roles  
        if rbac_data['roles']:
            for role in rbac_data['roles']:
                print(yaml.dump(role, default_flow_style=False).rstrip())
                print("---")
        
        # Print RoleBinding/ClusterRoleBinding templates
        bindings = self._create_binding_yaml(rbac_data, operator_name)
        if bindings:
            for binding_yaml in bindings:
                print(binding_yaml.rstrip())
                print("---")
    
    def deploy_rbac_yaml(self, rbac_data: Dict[str, Any], operator_name: str) -> None:
        """
        Deploy RBAC resources directly to cluster using oc apply.
        
        Args:
            rbac_data: RBAC resources dictionary  
            operator_name: Operator name for logging
        """
        logging.info(f"ðŸš€ Deploying RBAC for operator: {operator_name}")
        
        # Check if oc command is available
        try:
            subprocess.run(['oc', 'version', '--client'], 
                          capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            raise Exception("'oc' command not found. Please install OpenShift CLI")
        
        # Prepare YAML content for deployment
        yaml_content = []
        
        # Add ClusterRoles
        if rbac_data['clusterRoles']:
            for cluster_role in rbac_data['clusterRoles']:
                yaml_content.append(yaml.dump(cluster_role, default_flow_style=False))
        
        # Add Roles
        if rbac_data['roles']:
            for role in rbac_data['roles']:
                yaml_content.append(yaml.dump(role, default_flow_style=False))
        
        # Add RoleBinding/ClusterRoleBinding templates
        bindings = self._create_binding_yaml(rbac_data, operator_name)
        if bindings:
            yaml_content.extend(bindings)
        
        if not yaml_content:
            logging.warning(f"No RBAC resources to deploy for {operator_name}")
            return
        
        # Combine all YAML content
        full_yaml = "---\n".join(yaml_content)
        
        try:
            # Deploy using oc apply -f -
            cmd = ['oc', 'apply', '-f', '-']
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            stdout, stderr = process.communicate(input=full_yaml)
            
            if process.returncode == 0:
                logging.info(f"âœ… Successfully deployed RBAC for {operator_name}")
                if stdout.strip():
                    for line in stdout.strip().split('\n'):
                        logging.info(f"   {line}")
            else:
                raise Exception(f"oc apply failed: {stderr}")
                
        except Exception as e:
            logging.error(f"âŒ Failed to deploy RBAC for {operator_name}: {e}")
            raise
    
    def _create_binding_templates(self, operator_dir: Path, rbac_data: Dict[str, Any], 
                                 operator_name: str) -> None:
        """
        Create RoleBinding and ClusterRoleBinding templates.
        
        Args:
            operator_dir: Directory to save files
            rbac_data: RBAC data with service account info
            operator_name: Operator name for consistent resource naming
        """
        service_account = rbac_data.get('serviceAccount', f'{operator_name}-sa')
        
        # ClusterRoleBinding
        if rbac_data['clusterRoles']:
            cluster_role_binding = {
                'apiVersion': 'rbac.authorization.k8s.io/v1',
                'kind': 'ClusterRoleBinding',
                'metadata': {
                    'name': f'{operator_name}-cluster-role-binding'
                },
                'roleRef': {
                    'apiGroup': 'rbac.authorization.k8s.io',
                    'kind': 'ClusterRole',
                    'name': f'{operator_name}-cluster-role'  # Consistent with ClusterRole name
                },
                'subjects': [{
                    'kind': 'ServiceAccount',
                    'name': service_account,
                    'namespace': '{{ .Release.Namespace }}'
                }]
            }
            
            crb_file = operator_dir / "clusterrolebinding.yaml"
            with open(crb_file, 'w') as f:
                yaml.dump(cluster_role_binding, f, default_flow_style=False)
            logging.info(f"Saved ClusterRoleBinding: {crb_file}")
        
        # RoleBinding  
        if rbac_data['roles']:
            role_binding = {
                'apiVersion': 'rbac.authorization.k8s.io/v1',
                'kind': 'RoleBinding',
                'metadata': {
                    'name': f'{operator_name}-role-binding',
                    'namespace': '{{ .Release.Namespace }}'
                },
                'roleRef': {
                    'apiGroup': 'rbac.authorization.k8s.io',
                    'kind': 'Role',
                    'name': f'{operator_name}-role'  # Consistent with Role name
                },
                'subjects': [{
                    'kind': 'ServiceAccount',
                    'name': service_account,
                    'namespace': '{{ .Release.Namespace }}'
                }]
            }
            
            rb_file = operator_dir / "rolebinding.yaml"  
            with open(rb_file, 'w') as f:
                yaml.dump(role_binding, f, default_flow_style=False)
            logging.info(f"Saved RoleBinding: {rb_file}")
    
    def _create_binding_yaml(self, rbac_data: Dict[str, Any], operator_name: str) -> List[str]:
        """
        Create RoleBinding and ClusterRoleBinding YAML as strings.
        
        Args:
            rbac_data: RBAC data with service account info
            operator_name: Operator name for consistent resource naming
            
        Returns:
            List of YAML strings for bindings
        """
        bindings = []
        service_account = rbac_data.get('serviceAccount', f'{operator_name}-sa')
        
        # ClusterRoleBinding
        if rbac_data['clusterRoles']:
            cluster_role_binding = {
                'apiVersion': 'rbac.authorization.k8s.io/v1',
                'kind': 'ClusterRoleBinding',
                'metadata': {
                    'name': f'{operator_name}-cluster-role-binding'
                },
                'roleRef': {
                    'apiGroup': 'rbac.authorization.k8s.io',
                    'kind': 'ClusterRole',
                    'name': f'{operator_name}-cluster-role'
                },
                'subjects': [{
                    'kind': 'ServiceAccount',
                    'name': service_account,
                    'namespace': '{{ .Release.Namespace }}'
                }]
            }
            bindings.append(yaml.dump(cluster_role_binding, default_flow_style=False))
        
        # RoleBinding
        if rbac_data['roles']:
            role_binding = {
                'apiVersion': 'rbac.authorization.k8s.io/v1',
                'kind': 'RoleBinding',
                'metadata': {
                    'name': f'{operator_name}-role-binding',
                    'namespace': '{{ .Release.Namespace }}'
                },
                'roleRef': {
                    'apiGroup': 'rbac.authorization.k8s.io',
                    'kind': 'Role',
                    'name': f'{operator_name}-role'
                },
                'subjects': [{
                    'kind': 'ServiceAccount',  
                    'name': service_account,
                    'namespace': '{{ .Release.Namespace }}'
                }]
            }
            bindings.append(yaml.dump(role_binding, default_flow_style=False))
        
        return bindings
    
    def process_package_rbac(self, package_name: str, rbac_resources: Dict[str, Any]) -> None:
        """
        Process RBAC resources for a single package using configured output mode.
        
        Args:
            package_name: Name of the operator package
            rbac_resources: RBAC resources dictionary from library
        """
        logging.info(f"Processing RBAC for operator: {package_name}")
        
        try:
            if self.deploy:
                # Deploy directly to cluster
                self.deploy_rbac_yaml(rbac_resources, package_name)
            elif self.output_dir:
                # Save to files in specified directory
                self.save_rbac_yaml(rbac_resources, package_name)
            else:
                # Print to stdout (default)
                self.print_rbac_yaml(rbac_resources, package_name)
        except Exception as e:
            logging.error(f"Error processing RBAC for package {package_name}: {e}")
            raise
